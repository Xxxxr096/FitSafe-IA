<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Athena – En cours d’entraînement | FitSafe AI</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600;900&family=Poppins:wght@300;500&display=swap" rel="stylesheet">

  <style>
    * { margin:0; padding:0; box-sizing:border-box; }

    body {
      width:100%;
      height:100vh;
      overflow:hidden;
      background:#000;
      font-family:'Poppins',sans-serif;
      color:#fff;
      display:flex;
      justify-content:center;
      align-items:center;
      flex-direction:column;
    }

    #container {
      position:fixed;
      top:0; left:0;
      width:100%; height:100%;
      z-index:1;
    }

    .overlay {
      position:fixed;
      top:0; left:0;
      width:100%; height:100%;
      background:radial-gradient(circle at center, rgba(0,0,0,0.15), rgba(0,0,0,0.9) 80%);
      z-index:2;
    }

    .content {
      position:relative;
      z-index:3;
      text-align:center;
      padding:2rem;
      max-width:700px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
    }

    h1 {
      font-family:'Orbitron',sans-serif;
      font-size:clamp(2rem,6vw,4rem);
      background:linear-gradient(90deg,#ef4444,#ff006e,#00ffff,#ef4444);
      background-size:300%;
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      animation:glow-shift 4s linear infinite;
      text-shadow:0 0 20px rgba(255,255,255,0.3);
    }

    @keyframes glow-shift {
      0% { background-position: 0%; }
      100% { background-position: 300%; }
    }

    p {
      color:#b0b0b0;
      font-size:1.2rem;
      margin-top:1rem;
      line-height:1.6;
      max-width:550px;
    }

    .progress {
      margin-top:2.5rem;
      width:260px;
      height:5px;
      background:rgba(255,255,255,0.15);
      border-radius:3px;
      overflow:hidden;
      box-shadow:0 0 15px rgba(255,255,255,0.1);
    }

    .fill {
      width:0%;
      height:100%;
      background:linear-gradient(90deg,#ef4444,#ff006e,#00ffff,#ef4444);
      background-size:300%;
      animation:fillmove 10s linear infinite, glow-shift 6s linear infinite;
      box-shadow:0 0 20px rgba(255,255,255,0.3);
    }

    @keyframes fillmove {
      0%{width:0%;}
      100%{width:100%;}
    }

    footer {
      position:fixed;
      bottom:0;
      width:100%;
      text-align:center;
      padding:1.2rem 0;
      font-size:0.9rem;
      color:#777;
      border-top:1px solid rgba(255,255,255,0.08);
      background:rgba(0,0,0,0.6);
      backdrop-filter:blur(6px);
      z-index:5;
    }

    footer a {
      color:#00ffff;
      text-decoration:none;
      margin:0 0.5rem;
      transition:all 0.3s ease;
    }

    footer a:hover {
      color:#ff006e;
      text-shadow:0 0 8px rgba(255,0,100,0.8);
    }
  </style>
</head>

<body>
  <div id="container"></div>
  <div class="overlay"></div>

  <div class="content">
    <h1>ATHENA</h1>
    <p>L’intelligence FitSafe apprend à te connaître...<br>
       Merci de patienter pendant la calibration de ses réseaux neuronaux.</p>
    <div class="progress"><div class="fill"></div></div>
  </div>

  <footer>
    © 2025 FitSafe AI — Propulsé par <span style="color:#ff006e;">Athena</span> 🤖 |
    <a href="#">Instagram</a> •
    <a href="#">LinkedIn</a> •
    <a href="#">Politique de confidentialité</a>
  </footer>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { GammaCorrectionShader } from 'three/addons/shaders/GammaCorrectionShader.js';

    let scene, camera, renderer, composer;
    let particleSystem, neuronNetwork = [], connections = [];
    const clock = new THREE.Clock();

    const numParticles = 20000;
    const numNeurons = 120;
    const connectionDistance = 4;
    const shapes = ['sphere', 'cube', 'torus', 'dna'];
    let currentShapeIndex = 0;
    let targetPositions = [];
    let animationProgress = 1;
    const animationDuration = 1.5;

    init();
    animate();
    setInterval(changeShape, 10000);

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.z = 8;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.getElementById('container').appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableZoom = false;
      controls.enablePan = false;

      // Lumières
      scene.add(new THREE.AmbientLight(0xffffff, 0.5));

      // --- Réseau neuronal 3D ---
      createNeuronNetwork();

      // --- Particules centrales d'Athena ---
      createAthenaCore();

      // Post-processing
      composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.9, 0.5, 0.9);
      composer.addPass(bloom);
      composer.addPass(new ShaderPass(GammaCorrectionShader));

      window.addEventListener('resize', onResize);
    }

    function createNeuronNetwork() {
      const neuronGeo = new THREE.SphereGeometry(0.05, 8, 8);
      const neurons = [];

      for (let i = 0; i < numNeurons; i++) {
        const color = Math.random() > 0.5 ? 0x00ffff : 0xff0044;
        const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.8 });
        const node = new THREE.Mesh(neuronGeo, mat);
        node.position.set((Math.random()-0.5)*20, (Math.random()-0.5)*10, (Math.random()-0.5)*15);
        scene.add(node);
        neurons.push(node);
      }

      const material = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.2 });

      for (let i = 0; i < neurons.length; i++) {
        for (let j = i + 1; j < neurons.length; j++) {
          const a = neurons[i].position;
          const b = neurons[j].position;
          const dist = a.distanceTo(b);
          if (dist < connectionDistance && Math.random() < 0.3) {
            const lineGeo = new THREE.BufferGeometry().setFromPoints([a, b]);
            const line = new THREE.Line(lineGeo, material.clone());
            line.userData = { baseOpacity: Math.random() * 0.3 + 0.1, speed: Math.random() * 2 + 0.5 };
            scene.add(line);
            connections.push(line);
          }
        }
      }

      neuronNetwork = neurons;
    }

    function createAthenaCore() {
      const geometry = new THREE.SphereGeometry(2, 64, 64);
      const positions = new Float32Array(numParticles * 3);
      const colors = new Float32Array(numParticles * 3);

      for (let i = 0; i < numParticles; i++) {
        const phi = Math.acos(-1 + (2 * i) / numParticles);
        const theta = Math.sqrt(numParticles * Math.PI) * phi;
        const x = Math.sin(phi) * Math.cos(theta);
        const y = Math.sin(phi) * Math.sin(theta);
        const z = Math.cos(phi);
        positions[i*3] = x * 2.0;
        positions[i*3+1] = y * 2.0;
        positions[i*3+2] = z * 2.0;

        const hue = (i / numParticles) * 360;
        const color = new THREE.Color(`hsl(${hue},100%,60%)`);
        colors[i*3] = color.r;
        colors[i*3+1] = color.g;
        colors[i*3+2] = color.b;
      }

      const bufferGeometry = new THREE.BufferGeometry();
      bufferGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      bufferGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      const material = new THREE.PointsMaterial({
        size: 0.035,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        transparent: true,
        opacity: 0.9
      });

      particleSystem = new THREE.Points(bufferGeometry, material);
      scene.add(particleSystem);
      targetPositions = positions.slice();
    }

    function changeShape() {
      const shape = shapes[currentShapeIndex];
      morphToShape(shape);
      currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
    }

    function morphToShape(type) {
      let vertices = [];
      const getVerts = geo => {
        const attr = geo.getAttribute('position');
        const verts = [];
        for (let i = 0; i < attr.count; i++) {
          const v = new THREE.Vector3();
          v.fromBufferAttribute(attr, i);
          verts.push(v);
        }
        return verts;
      };

      switch (type) {
        case 'sphere': vertices = getVerts(new THREE.SphereGeometry(2, 64, 64)); break;
        case 'cube': vertices = getVerts(new THREE.BoxGeometry(3, 3, 3)); break;
        case 'torus': vertices = getVerts(new THREE.TorusGeometry(1.8, 0.6, 32, 100)); break;
        case 'dna': vertices = createDNAShape(); break;
      }

      const len = vertices.length;
      for (let i = 0; i < numParticles; i++) {
        const v = vertices[i % len];
        targetPositions[i*3] = v.x;
        targetPositions[i*3+1] = v.y;
        targetPositions[i*3+2] = v.z;
      }
      animationProgress = 0;
    }

    function createDNAShape() {
      const points = [];
      const numPoints = 100;
      const radius = 1.5;
      const height = 3;
      const turns = 2;
      for (let i = 0; i < numPoints; i++) {
        const t = (i / numPoints) * Math.PI * 2 * turns;
        const y = (i / numPoints) * height - height / 2;
        const x1 = Math.cos(t) * radius;
        const z1 = Math.sin(t) * radius;
        points.push(new THREE.Vector3(x1, y, z1));
        const x2 = Math.cos(t + Math.PI) * radius;
        const z2 = Math.sin(t + Math.PI) * radius;
        points.push(new THREE.Vector3(x2, y, z2));
      }
      return points;
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      scene.rotation.y += delta * 0.03;
      connections.forEach(line => {
        const t = Math.sin(clock.elapsedTime * line.userData.speed) * 0.5 + 0.5;
        line.material.opacity = line.userData.baseOpacity + t * 0.3;
      });

      if (particleSystem) {
        particleSystem.rotation.y += delta * 0.1;
        if (animationProgress < 1) {
          animationProgress += delta / animationDuration;
          const pos = particleSystem.geometry.attributes.position.array;
          for (let i = 0; i < numParticles * 3; i++) {
            pos[i] += (targetPositions[i] - pos[i]) * 0.05;
          }
          particleSystem.geometry.attributes.position.needsUpdate = true;
        }
      }

      composer.render();
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }
  </script>
  <!-- === Plein écran === -->
<div id="fullscreen-overlay"
     style="position:fixed;inset:0;background:rgba(0,0,0,0.85);
            color:white;display:flex;flex-direction:column;
            align-items:center;justify-content:center;
            z-index:9999;font-family:'Poppins',sans-serif;">
  <h2 style="font-size:1.8rem;margin-bottom:1rem;">
    🌐 Mode immersif FitSafe AI
  </h2>
  <p style="color:#aaa;margin-bottom:2rem;">Clique pour passer en plein écran</p>
  <button id="enterFullscreenBtn"
          style="background:#ef4444;padding:0.8rem 1.8rem;
                 border:none;border-radius:1rem;
                 font-size:1.1rem;color:white;
                 cursor:pointer;transition:all 0.3s;">
    Activer le plein écran
  </button>
</div>

<script>
  const overlay = document.getElementById('fullscreen-overlay');
  const btn = document.getElementById('enterFullscreenBtn');

  function openFullscreen() {
    const el = document.documentElement;
    if (el.requestFullscreen) el.requestFullscreen();
    else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
    else if (el.msRequestFullscreen) el.msRequestFullscreen();
  }

  function closeFullscreen() {
    if (document.exitFullscreen) document.exitFullscreen();
    else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
    else if (document.msExitFullscreen) document.msExitFullscreen();
  }

  // Quand on clique sur le bouton
  btn.addEventListener('click', async () => {
    await openFullscreen();
    overlay.style.opacity = '0';
    overlay.style.pointerEvents = 'none';
    setTimeout(() => overlay.remove(), 600);
  });

  // Quand on quitte le plein écran (ESC)
  document.addEventListener('fullscreenchange', () => {
    if (!document.fullscreenElement) {
      // Revenir à l’état initial
      if (!document.body.contains(overlay)) document.body.appendChild(overlay);
      overlay.style.opacity = '1';
      overlay.style.pointerEvents = 'auto';
    }
  });
</script>

</body>
</html>
